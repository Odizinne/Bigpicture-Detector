#!/usr/bin/env python3

import subprocess
import time
import re
import atexit
import os
import shutil
import sys
import argparse
import logging

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

class Mode:
    def __init__(self, screen_command, audio, mode_name, screen_name):
        self.screen_command = screen_command
        self.audio = audio
        self.mode_name = mode_name
        self.screen_name = screen_name
        self.current_mode = False

    def activate(self):
        logger.info("Activating mode: %s", self.mode_name)
        self.switch_screen()
        self.switch_audio()
        self.current_mode = True

    def deactivate(self):
        self.current_mode = False

    def is_active(self):
        return self.current_mode

    def switch_screen(self):
        logger.info("Switching screen to: %s with command: %s", self.screen_name, self.screen_command)
        subprocess.run(self.screen_command, stdout=subprocess.DEVNULL)

    def switch_audio(self):
        while True:
            result = subprocess.run(['pactl', 'list', 'sinks'], stdout=subprocess.PIPE)
            sinks = result.stdout.decode('utf-8')
            for sink in sinks.split('\n\n'):
                if self.audio in sink:
                    match = re.search(r'Name: (.*)', sink)
                    if match:
                        node_name = match.group(1)
                        logger.info(f"Switching audio to: {node_name}")
                        subprocess.run(['pactl', 'set-default-sink', node_name])
                        return

def load_configuration():
    parser = argparse.ArgumentParser(description='Big Picture Detector')
    parser.add_argument('--gamemode-audio', '-ga', type=str, required=True, help='Audio for game mode')
    parser.add_argument('--desktopmode-audio', '-da', type=str, required=True, help='Audio for desktop mode')
    parser.add_argument('--desktopmode-screen', '-ds', type=str, required=True, help='Name of the desktopmode adapter')
    parser.add_argument('--gamemode-screen', '-gs', type=str, required=True, help='Name of the gamemode adapter')
    args = parser.parse_args()

    if not args.gamemode_audio or not args.desktopmode_audio:
        parser.error("Both --gamemode-audio and --desktopmode-audio are required")

    return args

def check_window_names():
    result = subprocess.run(['wmctrl', '-l'], stdout=subprocess.PIPE)
    windows = result.stdout.decode('utf-8')

    keywords = {"steam", "mode", "big", "picture"}

    for line in windows.splitlines():
        parts = line.split(None, 3)
        if len(parts) == 4:
            title = parts[3].lower()
            if all(keyword in title for keyword in keywords):
                return True

    return False

def read_sunshine_status():
    home_dir = os.path.expanduser("~")
    status_file = os.path.join(home_dir, ".local/share/sunshine_status/status.txt")
    
    return os.path.exists(status_file)

def get_session_type():
    session_type = os.getenv("XDG_SESSION_TYPE").lower()
    if session_type == "x11":
        return "x11"
    elif session_type == "wayland":
        desktop_session = os.getenv("XDG_CURRENT_DESKTOP").lower()
        if desktop_session == "gnome":
            return "gnome-wayland"
        elif desktop_session == "kde":
            return "kde-wayland"
    else:
        return "Unsupported"
    
def get_randr_command():
    session_type = get_session_type()
    
    if session_type == "x11":
        logger.info("Session type: X11. Using xrandr.")
        return "xrandr"
    elif session_type == "gnome-wayland":
        logger.info("Session type: GNOME Wayland. Using gnome-randr.")
        return "gnome-randr"
    elif session_type == "kde-wayland":
        logger.info("Session type: KDE Wayland. Using kscreen-doctor.")
        return "kscreen-doctor"
    else:
        logger.error(f"Unsupported session type: {session_type}")
        sys.exit(1)

def validate_commands(commands):
    for command in commands:
        if shutil.which(command) is None:
            logger.error(f"The required command '{command}' is not installed.")
            sys.exit(1)

def generate_screen_command(randr_command, output_screen, off_screen, session_type):
    if session_type == "x11" or session_type == "gnome-wayland":
        return [randr_command, '--output', output_screen, '--auto', '--output', off_screen, '--off']
    elif session_type == "kde-wayland":
        return [randr_command, f'output.{output_screen}.enable', f'output.{off_screen}.disable']

def main():
    args = load_configuration()
    session_type = get_session_type()
    randr_command = get_randr_command()
    validate_commands(['pactl', 'wmctrl', randr_command])
    
    external_screen = args.gamemode_screen
    internal_screen = args.desktopmode_screen
    logger.info(f"Game mode audio: {args.gamemode_audio}")
    logger.info(f"Desktop mode audio: {args.desktopmode_audio}")
    logger.info(f"Game mode screen: {external_screen}")
    logger.info(f"Desktop mode screen: {internal_screen}")
    
    gamemode = Mode(
        generate_screen_command(randr_command, external_screen, internal_screen, session_type),
        args.gamemode_audio,
        "Game Mode",
        external_screen
    )
    desktopmode = Mode(
        generate_screen_command(randr_command, internal_screen, external_screen, session_type),
        args.desktopmode_audio,
        "Desktop Mode",
        internal_screen
    )

    atexit.register(desktopmode.activate)
    if check_window_names() and not read_sunshine_status():
        gamemode.activate()
    else:
        desktopmode.current_mode = True

    try:
        while True:
            if check_window_names() and not read_sunshine_status():
                if not gamemode.is_active():
                    gamemode.activate()
                    desktopmode.deactivate()
            else:
                if not desktopmode.is_active():
                    desktopmode.activate()
                    gamemode.deactivate()
            time.sleep(1)
    except KeyboardInterrupt:
        logger.info("Exiting.")

if __name__ == "__main__":
    main()
